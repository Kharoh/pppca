# WARNING - Generated by {fusen} from dev/flat_full.Rmd: do not edit by hand

#' Point Process Principal Component Analysis (PPPCA)
#'
#' 
#' @description
#' Principal Component Analysis for Point Process data.
#' 
#' @details
#' The Principal Component Analysis for Point Process data is based on the 
#' Karhunen–Loève decomposition of the empirical *cumulative mass functions*.
#' 
#' See Picard et al (2024) or the tutorial vignette "PCA for Point Processes 
#' with Earthquake Data" for more details:
#' `vignette("01-introduction-pppca", package = "pppca")`
#' 
#' **Important:** if the point process occurrences are not numerical values 
#' (e.g. dates), they should be converted to numerical values before using 
#' this function.
#' 
#' @references
#' Picard, Franck, Vincent Rivoirard, Angelina Roche, and Victor 
#' Panaretos. 2024. “PCA for Point Processes.” arXiv. 
#' \doi{10.48550/arXiv.2404.19661}.
#'
#' @param PP list of **numerical** vectors containing occurrences of each 
#' individual realization of the point process.
#' @param Jmax integer, number of principal components to consider.
#' @inheritParams parallel::mclapply
#'
#' @return PCA decomposition as a list containing:
#' - `grid`: numerical vector of the union of all occurrences of all point 
#'   process realizations in `PP` input argument.
#' - `eigenval`: numerical vector of length `Jmax` containing eigenvalues for 
#'   each principal component.
#' - `percentvar`: numerical vector of length `Jmax` containing the percentage 
#'   of variance in the data explained by each principal component.
#' - `eigenfun`: data frame containing the values of the eigenfunctions for 
#'   each principal components (in columns) over the occurrence `grid` 
#'   (in rows).
#' - `scores`: data frame of individual scores (in rows) for each 
#'   principal component (in columns).
#' @export
#' 
#' @importFrom graphics hist
#' @importFrom parallel mcmapply
#' @importFrom parallelly availableCores
#' @importFrom RSpectra eigs_sym
#'
#' @examples
#' # conversion of dates to numerical values
#' earthquake_num <- lapply(earthquake, as.numeric)
#' # apply principal component analysis to point process data
#' pppca_res <- pppca(earthquake_num, Jmax = 50, mc.cores = 1)
pppca <- function(PP, Jmax, mc.cores = parallelly::availableCores()) {
    grid <- sort(unique(Reduce('c', PP)))
    dgrid <- diff(grid)
    nb_occ_by_process <- sapply(PP, length)
    nb_occ_total <- length(grid)
    nb_processes <- length(PP)
    
    Lambda <- 0:(nb_occ_total-1) / nb_processes			
    Pi <- t(mcmapply(PP, FUN = function(x) {
        c(0, cumsum(hist(x, breaks = grid, plot = FALSE)$counts))
    }, mc.cores=mc.cores))
    K_Delta <- crossprod(Pi)/nb_processes - tcrossprod(Lambda)
    M_Delta <- tcrossprod(sqrt(dgrid)) * K_Delta[2:nb_occ_total, 2:nb_occ_total]
    PP_PC <- eigs_sym(M_Delta, Jmax)
    
    eigenval <- PP_PC$values[1:Jmax]				
    
    baseline_pmf <- apply(Pi, 2, mean)[-nb_occ_total]
    Pi_centered_norm <- t(apply(Pi, 1, FUN = function(x) {
        (x[-nb_occ_total] - baseline_pmf) * sqrt(dgrid)
    }))
    scores <- Pi_centered_norm %*% PP_PC$vectors[, 1:Jmax]
    scores <- t(apply(scores, 1, FUN = function(x){ x/sqrt(eigenval) }))
    
    change_sign <- sign(PP_PC$vectors[nb_occ_total/2, 1])
    
    scores[, 1] <- change_sign * scores[, 1]
    scores <- as.data.frame(scores)
    colnames(scores) <- paste0("axis", c(1:Jmax))
    
    eigenfun <- PP_PC$vectors[, 1:Jmax] / sqrt(dgrid)
    eigenfun[, 1]    <- change_sign * eigenfun[, 1]
    eigenfun <- data.frame(eigenfun)
    names(eigenfun) <- paste0("fun", c(1:Jmax))
    
    return(
        list(
            grid = grid,
            eigenval = eigenval,
            percentvar = 100 * eigenval / sum(eigenval),
            eigenfun = eigenfun, 
            scores = scores
        )
    )
}
