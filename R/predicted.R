# WARNING - Generated by {fusen} from dev/flat_full.Rmd: do not edit by hand

#' Predicted cumulative probability mass function
#'
#' 
#' @description
#' Compute the predicted cumulative mass function (PMF) for each realization 
#' of the point process using the Karhunen–Loève decomposition associated 
#' with the PPPCA decomposition.
#' 
#' @details
#' The predicted cumulative PMF values for each indidividual point process 
#' realization are computed along the union of all individual point process 
#' occurrences.
#' 
#' See Picard et al (2024) or the tutorial vignette "PCA for Point Processes 
#' with Earthquake Data" for more details:
#' `vignette("01-introduction-pppca", package = "pppca")`
#' 
#' @references
#' Picard, Franck, Vincent Rivoirard, Angelina Roche, and Victor 
#' Panaretos. 2024. “PCA for Point Processes.” arXiv. 
#' \doi{10.48550/arXiv.2404.19661}.
#' 
#' @seealso [pppca::pppca()], [pppca::get_predicted_pmf()]
#'
#' @inheritParams get_predicted_pmf
#'
#' @return a matrix containing the values of the predicted PMF for 
#' each individual realization of the point process (in columns) over the 
#' union of all occurrences of all point process realizations (in rows).
#' @export
#' 
#' @importFrom parallel mclapply
#' @importFrom parallelly availableCores
#'
#' @examples
#' # conversion of dates to numerical values
#' earthquake_num <- lapply(earthquake, as.numeric)
#' # apply principal component analysis to point process data
#' pppca_res <- pppca(earthquake_num, Jmax = 50, mc.cores = 1)
#' # reconstruct predicted intensity function
#' pred_pmf <- get_predicted_intensity(
#'     earthquake, pppca_res$eigenval, pppca_res$scores, 
#'     pppca_res$eigenfun, mc.cores = 1
#' )
get_predicted_intensity <- function(
        PP, eigenval, scores, eigenfun, 
        mc.cores = parallelly::availableCores()) {
    pred_pmf <- get_predicted_pmf(PP, eigenval, scores, eigenfun, mc.cores)
    pred_int <- apply(pred_pmf, 2, FUN = function(x){diff(x)})
    return(pred_int)
}

#' Predicted cumulative probability mass function
#'
#' 
#' @description
#' Compute the predicted cumulative mass function (PMF) for each realization 
#' of the point process using the Karhunen–Loève decomposition associated 
#' with the PPPCA decomposition.
#' 
#' @details
#' The predicted cumulative PMF values for each indidividual point process 
#' realization are computed along the union of all individual point process 
#' occurrences.
#' 
#' See Picard et al (2024) or the tutorial vignette "PCA for Point Processes 
#' with Earthquake Data" for more details:
#' `vignette("01-introduction-pppca", package = "pppca")`
#' 
#' @references
#' Picard, Franck, Vincent Rivoirard, Angelina Roche, and Victor 
#' Panaretos. 2024. “PCA for Point Processes.” arXiv. 
#' \doi{10.48550/arXiv.2404.19661}.
#' 
#' @seealso [pppca::pppca()], [pppca::get_predicted_intensity()]
#'
#' @inheritParams pppca
#' @inheritParams build_predicted_pmf
#' @inheritParams parallel::mclapply
#'
#' @return a matrix containing the values of the predicted PMF for 
#' each individual realization of the point process (in columns) over the 
#' union of all occurrences of all point process realizations (in rows).
#' @export
#' 
#' @importFrom parallel mclapply mcmapply
#' @importFrom parallelly availableCores
#'
#' @examples
#' # conversion of dates to numerical values
#' earthquake_num <- lapply(earthquake, as.numeric)
#' # apply principal component analysis to point process data
#' pppca_res <- pppca(earthquake_num, Jmax = 50, mc.cores = 1)
#' # reconstruct predicted PMF
#' pred_pmf <- get_predicted_pmf(
#'     earthquake, pppca_res$eigenval, pppca_res$scores, 
#'     pppca_res$eigenfun, mc.cores = 1
#' )
get_predicted_pmf <- function(
        PP, eigenval, scores, eigenfun, 
        mc.cores = parallelly::availableCores()) {
    n <- length(PP)
    grid <- sort(unique(Reduce('c', PP)))
    PPbin <- mclapply(PP, grid, FUN = function(x, gg) {	
        y <- rep(0,length(gg))
        y[which(gg %in% x)] <- 1
        return(y)
    }, mc.cores = mc.cores)
    baseline_pmf <- cumsum(Reduce('+', PPbin))[-1]#/n
    pred_pmf <- mcmapply(1:n, FUN = function(i) {
        build_predicted_pmf(i,baseline_pmf, eigenval, scores, eigenfun)
    }, mc.cores = mc.cores)
    return(pred_pmf)
}
